# -*- coding: utf-8 -*-
"""230127.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1khUF4FKnRhip2GWwkVO3EkyD-qJSDN8h

###2023-01-27 python advanced project camp 3rd class

판다스 (엑셀과 유사)
: 표의 형식으로 활용할 수 있도록 해줌
url를 통해 csv, json과 같은 원격 파일 or 데이터베이스를 열 수 있음

- 데이터 보기 및 검사
- 데이터 필터 (부산 데이터만 따로), 정렬 및 그룹화
- 데이터 정제 (누락 값 확인 -> 특정한 값을 다른 값으로 대체)
"""

import pandas as pd
import numpy as np
from pandas import Series, DataFrame
import matplotlib.pyplot as plt

df = pd.read_html('https://ko.wikipedia.org/wiki/%EC%98%AC%EB%A6%BC%ED%94%BD_%EB%A9%94%EB%8B%AC_%EC%A7%91%EA%B3%84', header=0, index_col=0) # header = 제일 윗줄, index_col = 국가(loc코드) 이름이냐 데이터냐

df[0]

summer = df[0].iloc[:,:5] # 전체, 처음부터 4까지
summer

summer.columns = ['하계참가횟수', '금', '은', '동', '계'] # 칼럼 이름을 넣어줄 수 있음
summer

summer.sort_values('계', ascending=False) # summer 데이터를 금메달에 대해 정렬할 것임. ascending=False : 가장 큰 값부터 (내림차순) =True : 가장 작은 값부터 (오름차순)

summer.to_excel('하계올림픽메달.xlsx') # 코드가 저장된 곳에 엑셀 파일이 만들어짐

# DataFrame : (2차원 배열) 행과 열로 구분할 수 있음
# 인덱스를 별도로 지정하지 않으면 자동으로 정수로 지정 (한번 설정된 인덱스는 불변)

index = pd.date_range('1/1/2000', periods=8) # 날짜 무작위로 8개 생성
print(index)

df = pd.DataFrame(np.random.rand(8, 3), index=index, columns=list('ABC'))
df

print(df['B']) # 인덱스(날짜)와 함께 출력되며 출력되는 형태는 series로 출력됨 df는 2차원 배열인데 출력이 될 때는 1차원으로 바뀌어서 나온다.

df2 = df[df['B'] > 0.4]
df2

df2 = df2.T # x축, y축 위치 변경
df2

df['D'] = df['A'] / df['B'] # A열의 값을 B열의 값으로 나눈 값을 D열에 저장
df

df['E'] = np.sum(df, axis=1)
df.head() # 데이터가 위에서부터 5개가 뜸

df = df.div(df['C'], axis=0) # 행을 따라 동작함 
df.to_csv('test.csv') # csv 파일로 저장
df.head()

"""알고리즘 설계

1. 데이터 읽어오기
2. 궁금한 지역의 이름을 입력받음
3. 궁금한 지역의 인구 구조 저장
4. 궁금한 지역의 인구 구조와 가장 비슷한 인구 구조를 가진 지역 찾기
5. 가장 비슷한 곳의 인구 구조와 궁금한 지역의 인구 구조를 시각화함
"""

df = pd.read_csv('/content/drive/MyDrive/age.csv', encoding='cp949', index_col=0)
df.head()

df = df.div(df['총인구수'], axis=0) # 1(1) 전체 데이터를 총인구수로 나눠서 비율로 변환
del df['총인구수'], df['연령구간인구수'] # 1(2) 총인구수, 연령구간인구수 열 삭제

df.head()

name = input('원하는 지역의 이름을 입력해주세요 : ') # 2. 지역 이름 입력
a = df.index.str.contains(name) # 3. 해당 행을 찾아서 해당 지역의 인구 구조를 저장함
df2 = df[a]
df2

# 한글 폰트 다운
#!sudo apt-get install -y fonts-nanum
#!sudo fc-cache -fv
#!rm ~/.cache/matplotlib -rf

plt.rc('font', family='NanumBarunGothic')
df2.T.plot()
plt.show()

# 두 가지 방법으로 나타낼 수 있음.
# v1.

# 4(1)궁금한 지역 A의 인구 비율에서 B의 인구 비율을 뺀다
# x = df.sub(df2.iloc[0], axis=1)
# 4(2) A의 인구 비율에서 B의 인구 비율을 뺀 값의 제곱 값을 모두 더한다
# y = np.power(x, 2)
# z = y.sum(axis=1)

# 가장 차이가 적은 상위 5개 지역 시각화
# i = z.sort_values().index[:5] # 4(3) 그 차이가 가장 작은 지역 5곳을 찾음
# df.loc[i].T.plot() # 4(4) 결과를 꺾은선 그래프로 보여준다.
# plt.show()

#v2.
# 4. 궁금한 지역의 인구 구조와 가장 비슷한 인구 구조를 가진 지역 찾기
df.loc[np.power(df.sub(df2.iloc[0], axis=1), 2).sum(axis=1).sort_values().index[:5]].T.plot()
plt.show()

# 만약 나온 그래프를 저장하고 싶으면
# plt.savefig('A.png')