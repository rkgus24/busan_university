# -*- coding: utf-8 -*-
"""230126.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1rD0SqCRFe2mZkLbEISZ2NXvAdJ555A88

###2023-01-26 python advanced project camp 2nd class
"""

import numpy as np
import matplotlib.pyplot as plt

# Mask 응용

import cv2
from google.colab.patches import cv2_imshow
mask_image = cv2.imread('/content/drive/MyDrive/mask_python.png')
back_image = cv2.imread('/content/drive/MyDrive/iceberg.jpg')
mask_image = cv2.resize(mask_image, (300, 400)) # 동일한 크기로 맞추기
back_image = cv2.resize(back_image, (300, 400))

mask_ANDed = cv2.bitwise_and(mask_image, back_image) # and로 할 것이냐
mask_ORed = cv2.bitwise_or(mask_image, back_image) # or로 할 것이냐
mask_XORed = cv2.bitwise_xor(mask_image, back_image) # xor로 할 것이냐

cv2_imshow(mask_image) # 마스크
cv2_imshow(back_image) # 원본
cv2_imshow(mask_ANDed) # and
cv2_imshow(mask_ORed) # or
cv2_imshow(mask_XORed) # xor

############### error

# import cv2
# global img1, img2 # 두 이미지를 프로그램의 전체에서 사용할 수 있도록 함

# def on_change_weight(x): # 상단 트랙바 막대가 움직이게 되면 이 함수가 호출된다
  # weight = x / 100 # x의 값이 0에서 100사이 이므로 100으로 나누어 0에서 1사이 값으로 
  # img_merged = cv2.addWeighted(img1, 1-weight, img2, weight, 0)
  # cv2.imshow('Display', img_merged)

# cv2.namedWindow('Display')
# cv2.createTrackbar('weight', 'Display', 0, 100, on_change_weight)

# img1 = cv2.imread('/content/drive/MyDrive/green_back.png')
# img2 = cv2.imread('/content/drive/MyDrive/iceberg.jpg')
# img1 = cv2.resize(img1, (300, 400))
# img2 = cv2.resize(img2, (300, 400))

"""ex) 우리 동네 인구 분포 구조와 비슷한 동네
알고리즘 설계
1. 데이터 읽어오기
2. 궁금한 지역의 이름을 입력받음
3. 궁금한 지역의 인구 구조 저장
4. 궁금한 지역의 인구 구조와 가장 비슷한 인구 구조를 가진 지역 찾기
5. 가장 비슷한 곳의 인구 구조와 궁금한 지역의 인구 구조를 시각화함
"""

import csv
f = open('/content/drive/MyDrive/age.csv', encoding='CP949') # f안에는 파일 자체가 들어있음.
data = csv.reader(f) # 파일 안에 있는 데이터를 읽음 (실제 텍스트가 저장됨)
next(data) # 파일의 가장 위쪽에 속성값들이 적혀있음. 통계 데이터가 아닌 속성값들 즉, 윗줄을 날리기 위함
home = [] # 입력 받은 지역의 데이터를 저장할 리스트 생성
name = input("인구 구조가 알고 싶은 지역의 이름 (읍면도 단위)을 입력해주세요 : ")
for row in data: # 전체 데이터를 한 줄씩 읽어와서
  if name in row[0]: # 지역명이 적혀있는 0번째 자리에 사용자가 입력한 것이 들어 있다면 (입력 받은 지역의 이름이 포함된 행 찾기)
    home = np.array(row[3:], dtype=int) # np.array를 가지고 3번째 행부터 끝까지의 데이터를 home에 저장해라
print(home) # home을 출력해라.

!sudo apt-get install -y fonts-nanum
!sudo fc-cache -fv
!rm ~/.cache/matplotlib -rf

plt.style.use('ggplot')
plt.figure(figsize = (10,5), dpi=80)
plt.rc('font', family='NanumBarunGothic')
plt.title(name + ' 지역의 인구 구조')

plt.plot(home)
plt.show()

# 1. 데이터 읽어오기

f = open('/content/drive/MyDrive/age.csv', encoding='CP949')
data = csv.reader(f)
next(data)
data = list(data)

# 2. 궁금한 지역의 이름 입력받기

name = input('인구 구조가 알고 싶은 지역의 이름 (읍면동 단위)을 입력해주세요 : ')
mn = 1 # 차이가 작은 대상을 찾기 위해 비교값을 넣는음
result_name = '' # 가장 작은 차이로 비슷한 지역의 이름을 넣음
result = 0

# 3. 궁금한 지역의 인구 구조를 저장한다

for row in data:
  if name in row[0]:
    home = np.array(row[3:], dtype=int) / int(row[2]) # 전체 인구수로 나눠서 비율로 저장함

# 4. 궁금한 지역의 인구 구조와 가장 비슷한 인구 구조를 가진 지역을 찾는다.

for row in data: # 데이터를 한 줄씩 (한 지역씩) 불러옴
  away = np.array(row[3:], dtype = int) / int(row[2]) # 그 지역에 해당하는 비율을 나타냄
  s = np.sum((home - away) ** 2) # 비율을 비교를 하고자 하는 비율과 빼고 제곱을 하여 합산을 하여 s에 저장
  if s < mn and name not in row[0]: # s의 값이 비교 대상자가 아니고 mn보다 작으면
    mn = s # mn에 s값을 넣고
    result_name = row[0] # 지역명
    result = away # 지역 비율
# 계속 for문을 돌며 가장 차이가 적은 지역명과 지역 비율을 알아낼 수 있을 것이다
  
# 5. 궁금한 지역의 인구 구조와 가장 비슷한 곳의 인구 구조를 시각화한다.

plt.style.use('ggplot')
plt.figure(figsize = (10,5), dpi=80) # dpi : 해상도
plt.rc('font', family='NanumBarunGothic') # 한글 폰트
plt.title(name + ' 지역과 가장 비슷한 인구 구조를 가진 지역')
plt.plot(home, label = name) # 비교할 대상의 지역, 차이가 적다고 생각하는 지역
plt.plot(result, label = result_name) # 내가 입력한 것, 내가 입력해서 나온 최소값의 지역
plt.legend() # 각각에 해당하는 그래프가 무엇을 나타내는지
plt.show()